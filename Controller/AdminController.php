<?php

/**
 * quickcheck Module
 *
 * The quickcheck module is a module for creating quizzes. It is attachable.
 *
 * @package      None
 * @subpackage   Quickcheck
 * @version      2.0
 * @author       Timothy Paustian
 * @copyright    Copyright (C) 2009 by Timothy Paustian
 * @license      http://www.gnu.org/copyleft/gpl.html GNU General Public License
 */


namespace Paustian\QuickcheckModule\Controller;

use Zikula\Core\Controller\AbstractController;
use Symfony\Component\Security\Core\Exception\AccessDeniedException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route; // used in annotations - do not remove
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method; // used in annotations - do not remove
use Symfony\Component\Routing\RouterInterface;
use Zikula_View;
use SecurityUtil;
use ModUtil;
use Loader;
use CategoryRegistryUtil;
/**
 * The various types of questions. We use defines to make the code
 * easier to read
 */

/**
 * @Route("/admin")
 *
 * Administrative controllers for the quickcheck module
 */

class AdminController extends \Zikula_AbstractController {

    const _QUICKCHECK_TEXT_TYPE = 0;
    const _QUICKCHECK_MULTIPLECHOICE_TYPE = 1;
    const _QUICKCHECK_TF_TYPE = 2;
    const _QUICKCHECK_MATCHING_TYPE = 3;
    const _QUICKCHECK_MULTIANSWER_TYPE = 4;
    
    /**
     * Post initialise.
     *
     * @return void
     */
    protected function postInitialize()
    {
        // In this controller we do not want caching.
        $this->view->setCaching(Zikula_View::CACHE_DISABLED);
    }
    
    /**
     * @Route("")
     * 
    */
    public function indexAction() {

       // Return a page of menu items.
       return new Response($this->view->fetch('Admin/quickcheck_admin_menu.tpl'));
    }
    
    /**
     * @Route("/newexam")
     * 
     * * form to add new exam
     *
     * Create a new exam
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new exam response object
     */

    public function newexamAction(Request $request) {
        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $button = $request->request->get('submit',null);
        $render = $this->view;
        $ret_url = $request->request->get('ret_url',null);
        $art_id = $request->request->get('art_id',null);

        if (!isset($art_id)) {
            throw NotFoundHttpException($this->__('You must create quizzes from modules that hook to the quiz module'));
        }
        switch ($button) {
            case 'create':
                // Create output object - this object will store all of our output so that
                // we can return it easily when required

                $questions = $this->_build_questions_list();

                $render->assign('questions', $questions);
                $render->assign('ret_url', $ret_url);
                $render->assign('art_id', $art_id);
                // Return the output that has been generated by this function
                return new Response($render->fetch('Admin\quickcheck_admin_new.tpl'));
                break;
            case 'modify':
                //pass this to modify2
                //first get the exam id, we need this to call modify2 correctly
                $exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('art_id' => $art_id));
                $submit = 'edit_' . $exam['id'];
                //now call the function
                return ModUtil::func('PaustianQuickcheckModule', 'admin', 'modify2', array('submit' => $submit));
                break;
            case 'remove':
                $exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('art_id' => $art_id));
                $exam['art_id'] = -1; //no article attached
                modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'update', $exam);
                return new RedirectResponse($ret_url);
                break;
            case 'attach':
                $exams = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getall');
                //mark the questions that should be checked.

                $render->assign('exams', $exams);
                $render->assign('ret_url', $ret_url);
                $render->assign('art_id', $art_id);
                return new Response($render->fetch('Admin\quickcheck_admin_attach.tpl'));
                break;
        }
    }
    
    
    /**
     * @Route ("/attach")
     * @Method("POST")
     * @param Request $request
     * 
     * Parameters of the request are:
     *  ret_url the URL to return to after being done
     *  art_id the article Id of the item that the exam is being attached to
     *  exam the exam that is being attached to the article
     * 
     * @return RedirectResponse
     */
    public function attachAction(Request $request) {
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        //get the values
        $ret_url = $request->request->get('ret_url',null);
        $art_id = $request->request->get('art_id',null);
        $exam = $request->request->get('exam',null);

        //arguments check
        if (!isset($ret_url)) {
            throw new NotFoundHttpException($this->__('A return URL is required'));
        }
        if (!isset($art_id) || !isset($exam)) {
            throw new NotFoundHttpException($this->__('An article id or exam id are missing'));
        }

        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            throw new AccessDeniedException();;
        }
        //get rid of the old exam if there is one.
        $old_exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('art_id' => $art_id));
        if ($old_exam) {
            $old_exam['art_id'] = -1; //no article attached
            modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'update', $old_exam);
        }
        //modify the exam by grabbing it and then changing or adding the art_id
        $exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('id' => $exam));
        $exam['art_id'] = $art_id;
        //now update the exam
        if (modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'update', $exam)) {
            $request->getSession()->getFlashBag()->add('status', $this->__('The exam was attached.'));
        }
        //finally return to the page that called.
        return new RedirectResponse($ret_url);
    }

    private function _build_questions_list() {

        //I am completely stumped on this one. For some reason, calling this funcion inserts a '1' into the
        //text that is returned. For the life of me I cannot find where it is.
        $items = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getallquestions');
        if (!$items) {
            return false;
        }

        $questions = array();
//    This needs to be changed to allow for organization by categoires.
//    The items array has the cat info in it. You just have to bin it.
//    Walk the list, and bin into an array, Each time a new category comes up
//    create a new item and then add each to the list.
        //The data structure is like this
        //$item{__CATEGORIES__][Main][id]
        //$item{__CATEGORIES__][Main][name]
        //use these two to build a multidminsional array
        // load the categories system

        $cat_id = -1;
        $cat_name = "";
        foreach ($items as $question) {
            //create the correct array for the chosen ID's to pass through correctly.
            $built_question['text'] = $question['q_text'];
            $built_question['value'] = $question['id'];
            $built_question['type'] = $question['q_type'];
            if (isset($question['__CATEGORIES__'])) {
                $built_question['cat_id'] = $question['__CATEGORIES__']['Main']['id'];
                $built_question['name'] = $question['__CATEGORIES__']['Main']['name'];
                $questions[$question['__CATEGORIES__']['Main']['sort_value']][] = $built_question;
            } else {
                $built_question['cat_id'] = -1;
                $built_question['name'] = "Uncatagorized";
                $questions['none'][] = $built_question;
            }
        }
        //sort the questions by category name
        ksort($questions);
        //now flatten it out a bit.
        $ret_quest = array();
        foreach ($questions as $question) {
            $ret_quest = array_merge($ret_quest, $question);
        }

        return $ret_quest;
    }
    
    /**
     * 
     * @Route("/create")
     * @Method("POST")
     * 
     * Create an exam.
     * @param Request $request
     * 
     * Take input from modify2action. Parameters of the request are:
     *  questions - questions to use in exam
     *  ret_url - the return url to redirect to
     *  art_id - the article id to attach if there
     *  name - the name of the exam.
     * 
     *  ret_url the URL to return to after being done
     *  art_id the article Id of the item that the exam is being attached to
     *  exam the exam that is being attached to the article
     * 
     * @return RedirectResponse
     */
    public function createAction(Request $request) {
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $questions = $request->request->get('questions',null);
        $ret_url = $request->request->get('ret_url',null);
        $art_id = $request->request->get('art_id',null);
        $name = $request->request->get('name',null);

        

        $items = modUtil::apiFunc('paustianquickcheckmodule', 'admin', 'create', array('quickcheckquestions' => $questions,
            'quickcheckart_id' => $art_id,
            'quickcheckname' => $name));

        if ($items) {
            SessionUtil::setVar('statusmsg', DataUtil::formatForDisplayHTML("Quick check created"));
        }

        // This function generated no output, and so now it is complete we redirect
        // the user to an appropriate page for them to carry on their work
        return new RedirectResponse($ret_url);
    }

    /**
     * @Route("/newtextquest")
     * form to add new text question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new text question
     */
    public function newTextQuestAction($args=array()) {
        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $render = $this->view;
        if (array_key_exists('q_text', $args)) {
            //if this is set, there is data to load into the form
            $render->assign('q_text', $args['q_text']);
            $render->assign('q_answer', $args['q_answer']);
            $render->assign('q_explan', $args['q_explan']);
            if (isset($args['id'])) {
                $render->assign('id', $args['id']);
            }
            if (isset($args['__CATEGORIES__']['Main'])) {
                $cat = $args['__CATEGORIES__']['Main'];
                if (is_array($cat)) {
                    $render->assign('selectedValue', $cat['id']);
                } else {
                    $render->assign('selectedValue', $cat);
                }
            }
        }
        // load the categories system
        if (!($class = Loader::loadClass('CategoryRegistryUtil'))) {
            pn_exit(pnML('_UNABLETOLOADCLASS', array('s' => 'CategoryRegistryUtil')));
        }

        $catregistry = CategoryRegistryUtil::getRegisteredModuleCategories('Quickcheck', 'quickcheck_quest');

        $render->assign('catregistry', $catregistry);
        return new Response($render->fetch('Admin\quickcheck_admin_new_text_question.tpl'));
    }
    
     /**
     * 
     * @Route("/createtextquestion")
     * @Method("POST")
     * 
     * Create an text question.
     * @param Request $request
     * 
     * Take input from modify2action. Parameters of the request are:
     *  q_text - The text of the quesiton
     *  q_answer - The answer to the question
     *  q_explan - The explanation of the answer
     *  name - the name of the exam.
     * 
     *  ret_url the URL to return to after being done
     *  art_id the article Id of the item that the exam is being attached to
     *  exam the exam that is being attached to the article
     * 
     * @return RedirectResponse
     */
  
    public function createTextQuestionAction(Request $request) {
       $this->checkCsrfToken();
        
       if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $button = $request->request->get('submit',null);

        if ($button == 'update') {
            $data['q_type'] = self::_QUICKCHECK_TEXT_TYPE;//text type question
            $id = $request->request->get('id',null);
            if (isset($id)) {
                $data['id'] = $id;
            }
            $data['q_text'] = $request->request->get('q_text',null);
            $data['q_answer'] = $request->request->get('q_answer',null);
            $data['q_explan'] = $request->request->get('q_explan');
            $cat = $request->request->get('quickcheck_quest');
            $data['__CATEGORIES__'] = $cat['__CATEGORIES__'];
            $data['q_param']= '';
            if ($this->_validate_createTextQuestion($data)) {
                if (isset($id)) {
                    ModUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'updatequestion', $data);
                    //if we have gotten here, we were successful
                    $request->getSession()->getFlashBag()->add('status', $this->__('Text question modified successfully.'));
                } else {
                    ModUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'createquestion', $data);
                    //if we have gotten here, we were successful
                    $request->getSession()->getFlashBag()->add('status', $this->__('New text question created.'));
                }
                
                return new RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_newtextquest', array(), RouterInterface::ABSOLUTE_URL));
            } else {
                //repeat the form but populate the fields
                return $this->newTextQuest($data);
            }
        }
        if ($args['commandName'] == 'cancel') {
            return new RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
        }
        return true;
    }

    private function _validate_createTextQuestion($inData) {
        $is_ok = true;
        //Make sure none of the fields are empty
        if (($inData['q_text'] == "") || $inData['q_answer'] == "") {
            $request->getSession()->getFlashBag()->add('status', $this->__("The question and/or answer are not filled in."));
            $is_ok = false;
        }
        return $is_ok;
    }

    /**
     * 
     * @Route("/newmatchquest")
     * 
     * form to add new matching question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       Response
     */
    public function newMatchQuestAction($args=array()) {
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $args['q_type'] = self::_QUICKCHECK_MATCHING_TYPE;
        $render = $this->_setup_MANSMATCH_form($args);
        // Return the output that has been generated by this function
        return new Response($render->fetch('Admin\quickcheck_admin_new_match_question.tpl'));
    }

    /**
     * @Route("/creatematchquestion")
     * @Method("POST")
     * 
     * Create an text question.
     * @param Request $request
     * 
     * Take input from modify2action. Parameters of the request are:
     *  q_text - The text of the quesiton
     *  q_answer - The answer to the question
     *  q_explan - The explanation of the answer
     *  q_param - The parameters for this question. These is the matching items
     * 
     * @return RedirectResponse
     */
    public function createMatchQuestionAction(Request $request) {
        
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $data['num_mc_choices'] = $request->request->get('num_mc_choices',null);
        $button = $request->request->get('submit',null);

        $data['q_param'] = $request->request->get('q_param',null);
        $data['q_text'] = $request->request->get('q_text',null);
        $data['q_answer'] = $request->request->get('q_answer',null);
        $data['q_explan'] = $request->request->get('q_explan',null);
        $data['id'] = $request->request->get('id',null);
        $cat = $request->request->get('quickcheck_quest',null);
        $data['__CATEGORIES__'] = $cat['__CATEGORIES__'];

        switch ($button) {
            case 'add':
                $data['num_mc_choices']++;

                //its faster not to call stuff through the usual zikula mechanism
                return $this->newMatchQuestAction($data);
                break;

            case 'remove':
                if ($data['num_mc_choices'] > 2) {
                    $data['num_mc_choices']--;
                }
                return $this->newMatchQuestAction($data);
                break;

            case 'create':
                if (!$this->_validate_createMatchQuestion($data)) {
                    //if the form is not valid, send it back to the user
                    //A suitable status message is also displayed.
                    return $this->newMatchQuestAction($data);
                }
//set the type of question
                $data['q_type'] = self::_QUICKCHECK_MATCHING_TYPE;

                //grab the various MC options
                if ($data['id'] == '') {
                    if (!modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'createquestion', $data)) {
                        return LogUtil::registerError($this->__("Creation of the matching question failed."));
                    }
                    SessionUtil::setVar('statusmsg', 'The question was created.');
                } else {
                    if (!modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'updatequestion', $data)) {
                        return LogUtil::registerError($this->__("Update of the matching question failed."));
                    }
                    $request->getSession()->getFlashBag()->add('status', $this->__("The question was modified."));
                }
                //if we have gotten here, we were successful
                return new RedirectReponse($this->get('router')->generate('quickcheck_admin_newMatchQuest', array(), RouterInterface::ABSOLUTE_URL));
                break;
            case 'cancel':
                return new RedirectReponse($this->get('router')->generate('quickcheck_admin_view', array(), RouterInterface::ABSOLUTE_URL));
                break;
        }
    }

    private function _validate_createMatchQuestion($inData) {
        $is_ok = true;
        //Make sure none of the fields are empty
        if (($inData['q_text'] == "") || $inData['q_explan'] == "") {
            $request->getSession()->getFlashBag()->add('status', $this->__("The question and/or explanation are not filled in."));
            $is_ok = false;
        }
        $answers = $inData['q_answer'];
        foreach ($answers as $item_text) {
            if ($item_text == "") {
                $request->getSession()->getFlashBag()->add('status', $this->__("One or more of your Facts is empty"));
                $is_ok = false;
                break;
            }
        }

        $matches = $inData['q_param'];
        ;
        foreach ($matches as $item_text) {
            if ($item_text == "") {
                $request->getSession()->getFlashBag()->add('status', $this->__("One or more of your Matching Concepts is empty"));
                $is_ok = false;
                break;
            }
        }
        return $is_ok;
    }

    /**
     * @Route("/newtfquest")
     * form to add new TF question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new TF question
     */
    public function newTFQuestAction($args=array()) {
        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $render = $this->view;
        if (array_key_exists('q_text', $args)) {
            //if this is set, there is data to load into the form
            $render->assign('q_text', $args['q_text']);
            //only send this if the answer is false. Otherwise the
            //default setup is true.
            if ($args['q_answer'] == 0) {
                $render->assign('q_answer', $args['q_answer']);
            }
            $render->assign('q_explan', $args['q_explan']);
            if (isset($args['id'])) {
                $render->assign('id', $args['id']);
            }
            if (isset($args['__CATEGORIES__']['Main'])) {
                $cat = $args['__CATEGORIES__']['Main'];
                if (is_array($cat)) {
                    $render->assign('selectedValue', $cat['id']);
                } else {
                    $render->assign('selectedValue', $cat);
                }
            }
        }
        // load the categories system
        /*if (!($class = Loader::loadClass('CategoryRegistryUtil'))) {
            pn_exit(pnML('_UNABLETOLOADCLASS', array('s' => 'CategoryRegistryUtil')));
        }

        $catregistry = CategoryRegistryUtil::getRegisteredModuleCategories('Quickcheck', 'quickcheck_quest');

        $render->assign('catregistry', $catregistry);*/
        return new Response($render->fetch('Admin\quickcheck_admin_new_tf_question.tpl'));
    }
    
    
     /**
     * 
     * @Route("/createtfquest")
     * @Method("POST")
     * 
     * Create an text question.
     * @param Request $request
     * 
     * Take input from modify2action. Parameters of the request are:
     *  q_text - The text of the quesiton
     *  q_answer - The answer to the question
     *  q_explan - The explanation of the answer
     *  q_param - The parameters for this question. These is the matching items
     * 
     * @return RedirectResponse
     */
    public function createTFQuestAction(Request $request) {
        
        //security check
        $this->checkCsrfToken();
        
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        
        $button = $request->request->get('submit',null);

        if ($button == 'update') {
            $data['q_type'] = self::_QUICKCHECK_TF_TYPE;
            $id = $request->request->get('id',null);
            if (isset($id)) {
                $data['id'] = $id;
            }
            $data['q_text'] = $request->request->get('q_text',null);
            $answer = $request->request->get('q_answer',null);
            if ($answer === "true") {
                $data['q_answer'] = 1;
            } else {
                $data['q_answer'] = 0;
            }
            $data['q_explan'] = $request->request->get('q_explan',null);
            //not allowed to be null, but we don't use it for these
            //just add a dummy value.
            $data['q_param'] = '';

            $cat = $request->request->get('quickcheck_quest',null);
            $data['__CATEGORIES__'] = $cat['__CATEGORIES__'];

            if ($this->_validate_TFQuestion($data)) {
                if (isset($id)) {
                    $data['id'] = $id;
                    ModUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'updatequestion', $data);
                    //if we have gotten here, we were successful
                    $request->getSession()->getFlashBag()->add('status', $this->__('True/False question modified successfully.'));
                } else {
                    ModUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'createquestion', $data);
                    //if we have gotten here, we were successful
                    $request->getSession()->getFlashBag()->add('status', $this->__('New True/False question created.'));
                }
                $url = $this->get('router')->generate('paustianquickcheckmodule_admin_newtfquest', array(), RouterInterface::ABSOLUTE_URL);
                return new RedirectResponse($url);
            } else {
                //repeat the form but populate the fieles
                return $this->newTFQuest($data);
            }
        }
        if ($args['commandName'] == 'cancel') {
            return new RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
        }
        return true;
    }

    /**
     * _validate_TFQuestion. 
     * Check a tf question and maks sure it validates before updating
     * @param type $inData
     * @return boolean
     */
    private function _validate_TFQuestion($inData) {
        $is_ok = true;
        //Make sure none of the fields are empty
        if (($inData['q_text'] == "") || $inData['q_explan'] == "") {
            $request->getSession()->getFlashBag()->add('status', $this->__("The question and/or explanation are not filled in."));
            $is_ok = false;
        }
        if (($inData['q_answer'] != '0' && $inData['q_answer'] != '1')) {
            $request->getSession()->getFlashBag()->add('status', $this->__("You did choose true or false."));
            $is_ok = false;
        }
        return $is_ok;
    }

    
    /**
     * @Route("/newmcquestion")
     * 
     * Form to add a new multiple choice question
     * @param array $args
     * @return Response
     */
    public function newMCQuestAction($args=array()) {
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $args['q_type'] = self::_QUICKCHECK_MULTIPLECHOICE_TYPE;
        $render = $this->_setup_MANSMATCH_form($args);
        //TODO:This may not work, setting up a pointer to a function this way.
        $render->assign('pointer', 'newMCQuestAction');
        $url = $this->get('router')->generate('paustianquickcheckmodule_admin_createmcquestion', array(), RouterInterface::ABSOLUTE_URL);
        $render->assign('formURL', $url);
        // Return the output that has been generated by this function
        return new Response($render->fetch('Admin\quickcheck_admin_new_mc_question.tpl'));
    }

    /**
     * @Route("/createmcquestion")
     * @Method("POST")
     * 
     * createMCQuestionAction
     * create a multiple choice question.
     * 
     * @param Request $request
     * @return RedirectResponse
     */
    public function createMCQuestionAction(Request $request) {
         //security check
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        //write this now to handle the form.
        $data['num_mc_choices'] = $request->request->get('num_mc_choices',null);
        $button = $request->request->get('submit',null);
        $pointer = $request->request->get('pointer',null);
        $data['q_type'] = $request->request->get('q_type',null);
        $data['q_param'] = $request->request->get('per_correct',null);
        $data['q_text'] = $request->request->get('q_text',null);
        $data['q_answer'] = $request->request->get('q_answer',null);
        $data['q_explan'] = $request->request->get('q_explan',null);
        $data['id'] = $request->request->get('id',null);
        $cat = $request->request->get('quickcheck_quest',null);
        $data['__CATEGORIES__'] = $cat['__CATEGORIES__'];

        switch ($button) {
            case 'add':
                $data['num_mc_choices']++;

                //its faster not to call stuff through the usual zikula mechanism
                return $this->$pointer($data);
                break;

            case 'remove':
                if ($data['num_mc_choices'] > 2) {
                    $data['num_mc_choices']--;
                }
                return $this->$pointer($data);
                break;

            case 'create':
                if (!$this->_validate_createMCQuestion($data, $request)) {
                    //if the form is not valid, send it back to the user
                    //A suitable status message is also displayed.
                    return $this->$pointer($data);
                }
                //grab the various MC options
                if ($data['id'] == '') {
                    modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'createquestion', $data);
                    $request->getSession()->getFlashBag()->add('status', $this->__('The question was created'));
                } else {
                    modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'updatequestion', $data);
                    $request->getSession()->getFlashBag()->add('status', $this->__('The question was modified'));
                }
                //if we have gotten here, we were successful
                $url = $this->get('router')->generate('paustianquickcheckmodule_admin_newmcquest', array(), RouterInterface::ABSOLUTE_URL);
                return new RedirectResponse($url);
                break;
            case 'cancel':
                return new RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
                break;
        }
    }

    /**
     * _validate_createMCQuestion
     *
     * Check the data coming out of the form and make sure it acceptible. If not
     * send back false.
     *
     * @param       inData      The data from the form.
     * @author       Timothy Paustian
     * @return       The form for creating a new multiple choice question
     */
    private function _validate_createMCQuestion($inData, Request $request) {
        $is_ok = true;
        //Make sure none of the fields are empty
        if (($inData['q_text'] == "") || $inData['q_explan'] == "") {
            $request->getSession()->getFlashBag()->add('status', $this->__("The question and/or explanation are not filled in."));
            $is_ok = false;
        }
        $answer_percent = $inData['q_param'];
        $total_percent = 0;
        //add up all the percents, should total 100 for all question except text questions
        if ($inData['q_type'] != self::_QUICKCHECK_TEXT_TYPE) {
            foreach ($answer_percent as $percent) {
                $total_percent += $percent;
            }
            if ($total_percent != 100) {
                $request->getSession()->getFlashBag()->add('status', $this->__("The percent correct does not add up to 100"));
                $is_ok = false;
            }
        }
        $choices = $inData['q_answer'];
        foreach ($choices as $item_text) {
            if ($item_text == "") {
                $request->getSession()->getFlashBag()->add('status', $this->__("One or more of your choices is empty"));
                $is_ok = false;
                break;
            }
        }

        return $is_ok;
    }

    /**
     * @Route ("newmansquest")
     * @param   $args the 
     * form to add new multiple answer question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new multiple answe question
     */
    public function newMANSQuestAction($args=array()) {

        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $args['q_type'] = self::_QUICKCHECK_MULTIANSWER_TYPE;
        $render = $this->_setup_MANSMATCH_form($args);
        $render->assign('pointer', "newMANSQuestAction");
        $render->assign('MAtype', true);

        // Return the output that has been generated by this function
        return new Response($render->fetch('Admin\quickcheck_admin_new_mc_question.tpl'));
    }
    
    /**
     * 
     * @param $args the data coming in for set up
     * @return type
     * @throws AccessDeniedException
     */

    private function _setup_MANSMATCH_form($args) {

        if (!isset($args['num_mc_choices'])) {
            $num_mc_choices = 5;
        } else {
            $num_mc_choices = $args['num_mc_choices'];
        }

        // Create output object - this object will store all of our output so that
        // we can return it easily when required
        $render = $this->view;
        //a test array for now
        $render->assign('num_mc_choices', $num_mc_choices);
        //assign this parameter, its always set.
        $render->assign('type', $args['q_type']);

        if (isset($args['q_text'])) {
            $render->assign('q_param', $args['q_param']);
            $render->assign('q_text', $args['q_text']);
            $render->assign('q_answer', $args['q_answer']);
            $render->assign('q_explan', $args['q_explan']);
            $render->assign('id', $args['id']);
            if (isset($args['__CATEGORIES__']['Main'])) {
                $cat = $args['__CATEGORIES__']['Main'];
                if (is_array($cat)) {
                    $render->assign('selectedValue', $cat['id']);
                } else {
                    $render->assign('selectedValue', $cat);
                }
            }
        } else {
            $render->assign('q_text', "");
            $answers = array("", "", "", "", "");
            $render->assign('q_answer', $answers);
            $render->assign('q_param', $answers);
            $render->assign('q_explan', "");
            $render->assign('id', "");
        }
        //build the menu for the dropdown percent corect
        $percent_correct_val = array();
        for ($menu = 0; $menu < 101; $menu+=5) {
            $percent_correct_val[$menu] = $menu;
        }
        $render->assign('percent_correct_val', $percent_correct_val);

        // load the categories system
        /*if (!($class = Loader::loadClass('CategoryRegistryUtil'))) {
            z_exit($this->__("Unable to load class CategoryRegistryUtil"));
        }

        $catregistry = CategoryRegistryUtil::getRegisteredModuleCategories('Quickcheck', 'quickcheck_quest');
        $render->assign('catregistry', $catregistry);*/
        return $render;
    }

    /**
     * @Route ("modify")
     * 
     * modify an exam
     *
     * Set up a form to present all the exams and let the user choose
     * The one to modify
     */
    public function modifyAction() {
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            return DataUtil::formatForDisplayHTML($this->__("You do not have permission to add questions."));
        }
        //create a list to choose from. I think I will use radio buttons
        //because that is easier to deal with.
        $render = zikula_View::getInstance('Quickcheck', false);
        //get the exams
        $exams = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getall');
        $render->assign('exams', $exams);
        // Return the output that has been generated by this function
        return new Response($render->fetch('Admin\quickcheck_admin_modify.tpl'));
    }

    /**
     * 
     * modify2. The second phase of the modify form
     * @Route ("modify2")
     * @Method("POST")
     * 
     * @param Request $request
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    
    public function modify2Action(Request $request) {
         //security check
        $this->checkCsrfToken();
        
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        //Find out the button that was pressed
        $button = $request->request->get('submit',null);
        $redirect_url = $this->get('router')->generate('paustianquickcheckmodule_admin_modify', array(), RouterInterface::ABSOLUTE_URL);
        //delete all the checked items
        if ($button === 'delete_exams') {
            if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_DELETE)) {
                throw new AccessDeniedException();
            }
            $exams = $request->request->get('exams',null);
            //check to make sure we have something
            if (!empty($questions)) {
                //we have the list, now delete the questions
                foreach ($questions as $item) {
                    modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'delete', array('id' => $item));
                }
            }
            $request->getSession()->getFlashBag()->add('status', $this->__('The exams were deleted.'));
            return new RedirectResponse($redirect_url);
        }
        //it's not the delete button. determine value
        $string_data = explode("_", $button);
        //find the command we need to do
        $command = $string_data[0];
        //get the id the exam.
        $id = $string_data[1];
        if ($command == 'edit') {
            $the_exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('id' => $id));
            $curr_quest_array = array();
            $other_array = array();
            //grab the current questions.
            $questions = $this->_build_questions_list();
            $curr_quest_ids = $the_exam['questions'];

            //search the question array and pick out the ones that are
            //current questions
            foreach ($questions as $q_data) {
                $item['q_text'] = $q_data['text'];
                $item['id'] = $q_data['value'];

                if (array_search($q_data['value'], $curr_quest_ids) !== false) {
                    $curr_quest_array[] = $item;
                } else {
                    $item['cat_id'] = $q_data['cat_id'];
                    $item['cat_name'] = $q_data['name'];
                    $other_array[] = $item;
                }
            }

            $render = $this->view;
            $render->assign('exam', $the_exam);
            $render->assign('curr_questions', $curr_quest_array);
            $render->assign('other_questions', $other_array);
            return new Response($render->fetch('Admin\quickcheck_admin_modify2.tpl'));
        }
        return new RedirectResponse($redirect_url);
    }

    /**
     * @Route("/modifyquest")
     * 
     * modifyquest - modify a question.
     * 
     * @param type $args
     * @return type
     */
    public function modifyquestAction($args) {

        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $items = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getallquestions');

        if (!$items) {
            $request->getSession()->getFlashBag()->add('status', $this->__("There are no quesitons to modify"));
            return RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
        }

        // Create output object - this object will store all of our output so that
        // we can return it easily when required
        $render = zikula_View::getInstance('Quickcheck', false);
        $render->assign('questions', $items);
        //prepare your variables as you see fit
        // Return the output that has been generated by this function
        return new Response($render->fetch('Admin\quickcheck_admin_modifyquest.tpl'));
    }
    
    /**
     * 
     * modify2. The second phase of the modify form
     * @Route ("modifyquest2")
     * @Method("POST")
     * 
     * @param Request $request
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    

    public function modifyquest2Action(Request $request) {

         //security check
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }
        
        $id = $request->request->get('id',null);
        $redirect_url = $this->get('router')->generate('paustianquickcheckmodule_admin_editquestions', array(), RouterInterface::ABSOLUTE_URL);

        if (!isset($id)) {
            $request->getSession()->getFlashBag()->add('status', $this->__("The id is not set in modidfyquest2"));
            return RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
        }
        //grab the question
        $item = modUtil::apiFunc('PaustianQuickcheckmodule', 'user', 'getquestion', array('id' => $id));

        if (!$item) {
            $request->getSession()->getFlashBag()->add('status', $this->__("A question with that id does not exist"));
            return RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
        }

        switch ($item['q_type']) {
            case self::_QUICKCHECK_TEXT_TYPE:
                return $this->modifyTextQuest(array('item' => $item));
                break;
            case self::_QUICKCHECK_MATCHING_TYPE:
                return $this->modifyMatchQuest(array('item' => $item));
                break;
            case self::_QUICKCHECK_MULTIANSWER_TYPE:
                return $this->modifyMANSQuest(array('item' => $item));
                break;
            case self::_QUICKCHECK_MULTIPLECHOICE_TYPE:
                return $this->modifyMCQuest(array('item' => $item));
                break;
            case self::_QUICKCHECK_TF_TYPE:
                return $this->modifyTFQuest(array('item' => $item));
                break;
        }
    }

    /**
     * 
     * form to add modify a T/F question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new text question
     */
    public function modifyTFQuest($args) {

        $item = $request->request->get('item',null);

        return $this->newTFQuest($item);
    }

    private function _setup_form($inItem = null) {
        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            return DataUtil::formatForDisplayHTML($this->__("You do not have permission to add questions."));
        }

        // Create output object - this object will store all of our output so that
        // we can return it easily when required
        $render = zikula_View::getInstance('Quickcheck', false);
        if (isset($inItem)) {
            $render->assign('q_text', $inItem['q_text']);
            $render->assign('q_answer', $inItem['q_answer']);
            if (isset($inItem['q_explan'])) {
                $render->assign('q_explan', $inItem['q_explan']);
            }

            //I finally figured this out. I needed to pull out what from the categories
            //is getting selected. What is stored with my table, is the id of the item
            //selected. By assigning this to selectedValue in the template, it gets
            //chosen in the category menu. See the templates for the way it's handled.
            //I should probably be more clever and no just grab the 'Main' property,
            //but that is the one I am always going to use.
            if (isset($inItem['__CATEGORIES__']['Main'])) {
                $cat = $inItem['__CATEGORIES__']['Main'];
                //print "<br />";print $cat['id'];die;
                $render->assign('selectedValue', $cat['id']);
            }
        }
        return $render;
    }

    /**
     * form to add modify a text question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new text question
     */
    public function modifyTextQuest($args) {

        $item = $request->request->get('item',null);

        return( $this->newTextQuest($item));
    }

    private function _setUpMANSMC($data) {

        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $data['num_mc_choices'] = count($data['q_answer']);
        return $data;
    }

    public function modifyMCQuest(Request $request) {
        $data = $request->request->get('item',null);

        $data = $this->_setUpMANSMC($data);
        return $this->newMCQuest($data);
    }

    public function modifyMANSQuest(Request $request) {
        $data = $request->request->get('item',null);

        $data = $this->_setupMANSMC($data);

        return $this->newMANSQuest($data);
    }

    public function modifyMatchQuest(Request $request) {
        $data = $request->request->get('item',null);

        $data = $this->_setupMANSMC($data);
        return $this->newMatchQuest($data);
    }

    /**
     * 
     * @Route("/update")
     * @Method POST
     * 
     * Modify an exam
     *
     * This is a standard function that is called with the results of the
     * form supplied by quickcheck_admin_modify2() to update a current exam
     *
     * @param Request $request
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    
    public function updateAction(Request $request) {
        // Confirm authorisation code.
         //security check
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $curr_questions = $request->request->get('curr_questions',null);
        $other_questions = $request->request->get('other_questions',null);
        $name = $request->request->get('name',null);
        $id = $request->request->get('exam_id',null);
        if (isset($other_questions) && isset($curr_questions)) {
            $total_questions = array_merge($curr_questions, $other_questions);
        } else if (isset($other_questions)) {
            $total_questions = $other_questions;
        } else if (isset($curr_questions)) {
            $total_questions = $curr_questions;
        } else {
            $total_questions = array();
        }
        if (modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'update', array('name' => $name, 'id' => $id, 'questions' => $total_questions))) {
            $request->getSession()->getFlashBag()->add('status', $this->__("The exam was updated."));
        }
        return new RedirectResponse(ModUtil::url('PaustianQuickcheckModule', 'admin', 'modify'));
    }

    /**
     * @Route("/editquestions")
     * 
     * edit questions
     *
     *  This is the interface for modifying and deleting questions. I combined the
     *  two to make it more accessible to the user. The function displays a list of
     *  questions, and from there a user can edit or delete a question.
     * 
     * @return Response
     * @throws AccessDeniedException
     * 
     */
    public function editquestionsAction() {
        $questions = $this->_prep_question_list("yes");
        $render = zikula_View::getInstance('Quickcheck', false);
        $render->assign('questions', $questions);
        return new Response($render->fetch('Admin\quickcheck_admin_editquestions.tpl'));
    }

    private function _prep_question_list($buttons = "no") {

        //To use this function you need high access
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_DELETE)) {
            throw new AccessDeniedException();
        }

        $render = zikula_View::getInstance('Quickcheck', false);
        $questions = $this->_build_questions_list();

        if (!$questions) {
            return LogUtil::registerError('There are no questions to modify. Create some first.');
        }
        $render->assign('questions', $questions);
        $render->assign('buttons', $buttons);

        return new Response($render->fetch('Admin\quickcheck_admin_qpart.tpl'));
    }

    /**
     * @Route("/modifydeletequesions")
     * 
     * presents a list of questions that you can then modify or delete.
     * 
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    public function modifydeletequestionsAction() {

        //Find out the button that was pressed
        $button = $request->request->get('submit',null);
        if (!isset($button)) {
            $button = $request->request->get('plg4_update',null);
        }
        $redirect_url = $this->get('router')->generate('paustianquickcheckmodule_admin_editquestions', array(), RouterInterface::ABSOLUTE_URL);
        //delete all the checked items

        if ($button === 'delete_checked') {
            if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_DELETE)) {
                throw new AccessDeniedException();
            }
            $questions = $request->request->get('questions',null);
            $delete_all = $request->request->get('delete_all',null);
            //check to make sure we have something
            if (!empty($questions)) {
                //we have the list, now delete the questions
                foreach ($questions as $item) {
                    if (!modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'deletequestion', array('id' => $item))) {
                        $request->getSession()->getFlashBag()->add('status', $this->__("There was an error deleting the quesiton."));
                        return RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));;
                    }
                }
                //if we get here, it worked.
                $request->getSession()->getFlashBag()->add('status', $this->__("The choosen question(s) were deleted"));
            } else {
                if ($delete_all == "on") {
                    $questions = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getallquestions');
                    if (!$questions) {
                        $request->getSession()->getFlashBag()->add('status', $this->__('There are no questions to modify. Create some first.'));
                        return new RedirectResponse($redirect_url);
                    }
                    foreach ($questions as $q_item) {
                        if (!modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'deletequestion', array('id' => $q_item['id']))) {
                            //if we have an error, bail, the error is already posted.
                            return new RedirectResponse($redirect_url);
                        }
                    }
                    //if we got here, all the question are deleted, we need to redirect somewhere else
                    //post a status message too.
                    $request->getSession()->getFlashBag()->add('status', $this->__("All questions were deleted"));
                    return new RedirectResponse(ModUtil::url('PaustianQuickcheckModule', 'admin', 'editquestions'));
                }
            }
            return new RedirectResponse($redirect_url);
        }
        if ($button === 'modify_checked') {
            if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
                throw new AccessDeniedException();
            }
            //I have bad data in the MC, MAtching etc. questions Reimport I guess
            $questions = $request->request->get('questions',null);
            $id = $questions[0];
            return $this->modifyquest2(array('id' => $id));
        }
        //parse the button if we get to this point
        $button_parts = explode('_', $button);
        if ($button_parts[0] == "modify") {
            if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
                throw new AccessDeniedException();
            }
            //we want to edit the question identified. This is coming from find unanswered.
            //the second part of the phrase is the id of the button
            return $this->modifyquest2(array('id' => $button_parts[1]));
        }

        return new RedirectResponse($redirect_url);
    }


    /**
     * 
     * @Route("/manageexams")
     * @Method("POST")
     * 
     * @param Request $request
     * 
     * Manage exams
     *
     * This is the hook funciton that attaches/deletes/modifies an exam, with
     * questions, to another module. This is the interface that takes care of
     * those functions. What gets passed in, may be the id of the exam. If not
     * then we display an interface for choosing questions for the exam.
     * 
     * 
     */
    
    public function manageexamsAction(Request $request) {
        $art_id = $request->request->get('objectid', null);
        $ret_url = $request->request->get('extrainfo', null);
        $module = $request->request->get('extrainfo', null);
        $ret_text = "";
        $exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('art_id' => $art_id));

        if ($exam) {
            $ret_text = ModUtil::func('PaustianQuickcheckModule', 'user', 'display', array('exam' => $exam, 'returnurl' => $ret_url));
            $render = $this->view;
            $render->assign('hasexam', 1);
        }
        //no exam, display an interface to pick one, only if this is an admin
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            //we return an empty results for someone who cannot edit, you don't want to fail here
            //as each hooked page would then have the error message.
            return $ret_text;
        } else {
            $ret_text .= "<hr />" . ModUtil::func('PaustianQuickcheckModule', 'admin', 'pickquestions', array('returnurl' => $ret_url, 'art_id' => $art_id));
        }
        return $ret_text;
    }

    /**
     * @Route("/pickquestions")
     * @Method("POST")
     * 
     * Pick questions
     *
     * Display an interface for picking questions. Really this will just be a button
     * that will lead to a page where you can add questions to an exam.
     *
     * @param Request
     * @return Response
     */
    
    public function pickquestionsAction(Request $request) {
        // Confirm authorisation code.
         //security check
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $ret_url = $request->request->get('returnurl',null);
        $art_id = $request->request->get('art_id', null);
        $render = $this->view;
        $render->assign('ret_url', $ret_url);
        $render->assign('art_id', $art_id);
        return new Response($render->fetch('Admin\quickcheck_admin_pickquestions.tpl'));
    }
    
    /**
    * @Route("/categorize")
    *
    *
    * Display a list of questions with each having a checkbox. You choose a category and a checkboxe(s)
    * and each question is then added to that category.
    * @return Response 
    */
    
 public function categorizeAction() {
        $questions = $this->_prep_question_list();
        $render = zikula_View::getInstance('Quickcheck', false);
        $render->assign('questions', $questions);
        
        return new Response($render->fetch('Admin\quickcheck_admin_categorize.tpl'));
    }

    
    /**
     * @Route("/addtocategory")
     * @Method("POST")
     * 
     * Take the category that was recorded and  add it to the selected questions
     * 
     * @param Request $request
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    public function addtocategoryAction(Request $request) {
        // Confirm authorisation code.
         //security check
        $this->checkCsrfToken();
        
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        //get the questions
        $questions = $request->request->get('questions',null);
        //get the category
        $cat = $request->request->get('quickcheck_quest',null);
        foreach ($questions as $the_question) {
            $item = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getquestion', array('id' => $the_question));
            $item['__CATEGORIES__'] = $cat['__CATEGORIES__'];

            if (!modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'updatequestion', $item)) {
                return LogUtil::registerError("Update in category failed.");
            }
        }
        //if we have gotten here, we were successful
        $request->getSession()->getFlashBag()->add('status', $this->__('Categories updated.'));
        return new RedirectResponse(ModUtil::url('PaustianQuickcheckModule', 'admin', 'categorize'));
    }

    /**
     * @Route("/findunanswered")
     * 
     * findunanswered
     *
     * This is a quick function to find all the unexplained questions in the module
     * It's really a hack and isn't something you should be calling, I am just using
     * it for clean up of some previous data. It will likely go away in a future release
     *
     *  @return Response
     *  @throws AccessDeniedException
     */
    public function findunansweredAction() {
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $questions = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getallquestions', array('missing_explan' => true));

        $render = zikula_View::getInstance('Quickcheck', false);
        $render->assign('count', count($questions));
        $render->assign('questions', $questions);
        return new Response($render->fetch('Admin/quickcheck_admin_findunanswered.tpl'));
    }

  /**
   * @Route("/importquiz")
   * 
   * set up the interface to import an xml file of quiz questions.
   * @return Response
   * @throws AccessDeniedException
   */
    public function importquizAction() {
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }
        $render = zikula_View::getInstance('Quickcheck');
        return new Response($render->fetch('Admin/quickcheck_admin_importquiz.tpl'));
    }

    /**
     * @Route("/doimport")
     * @Method("POST")
     * 
     * import questions as xml
     *
     * Given a set of data in xml format, parse it and improt the questions. There
     * is a set format, with examples given in the template for the page
     *
     * @author      Tim Paustian
     * @param      Request
     * @return    RedirectReponse
     *
     */
    public function doimportAction(Request $request) {
        $ret_url = $this->get('router')->generate('paustianquickcheckmodule_admin_importquiz', array(), RouterInterface::ABSOLUTE_URL);
        // Confirm authorisation code.
         //security check
        $this->checkCsrfToken();
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        //get the questions
        $questions = $request->request->get('quest_to_import',null);

        if (modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'import', array('questions' => $questions))) {
            $request->getSession()->getFlashBag()->add('status', $this->__('Import of questions was successful.'));
            ;
        } else {
            LogUtil::registerError(__('The import of questions did not work, probably because of poorly formed xml or because of an illegal character'), null, $ret_url);
        }
        return new RedirectResponse($ret_url);
    }

    /**
     * @Route("/exportquiz")
     * 
     * exort the chose quiz. First step. This displays the interface to export the questions
     * @return Response
     * @throws AccessDeniedException
     */
    public function exportquizAction() {
        
        //You need edit access to export questions
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }
        $questions = $this->_prep_question_list("yes");
        $render = $this->view;
        $render->assign('questions', $questions);
        return new Response($render->fetch('Admin/quickcheck_admin_exportquiz.tpl'));
    }
    
    /**
     * @Route("/doexport")
     * @Method("POST")
     * 
     * Export the choosen questions into an xml file
     * 
     * @param Request $request
     * @throws AccessDeniedException
     */
    
    public function doexportAction(Request $request) {
        $ret_url = $this->get('router')->generate('paustianquickcheckmodule_admin_export', array(), RouterInterface::ABSOLUTE_URL);
        // Confirm authorisation code.
         //security check
        $this->checkCsrfToken();
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        //get the questions
        $export_all = $request->request->get('export_all',null);
        $q_ids = $request->request->get('questions',null);

        $q_xml = modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'export', array('export_all' => $export_all, 'q_ids' => $q_ids));

        $render = $this->view;
        $render->assign('questions', $q_xml);
        return new Response($render->fetch('Admin/quickcheck_admin_doexport.tpl'));
    }

}