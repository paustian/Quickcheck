<?php

/**
 * quickcheck Module
 *
 * The quickcheck module is a module for creating quizzes. It is attachable.
 *
 * @package      None
 * @subpackage   Quickcheck
 * @version      2.0
 * @author       Timothy Paustian
 * @copyright    Copyright (C) 2009 by Timothy Paustian
 * @license      http://www.gnu.org/copyleft/gpl.html GNU General Public License
 */

namespace Paustian\QuickcheckModule\Controller;

use Zikula\Core\Controller\AbstractController;
use Symfony\Component\Security\Core\Exception\AccessDeniedException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route; // used in annotations - do not remove
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method; // used in annotations - do not remove
use Symfony\Component\Routing\RouterInterface;
use Zikula_View;
use SecurityUtil;
use ModUtil;
use Loader;
use CategoryRegistryUtil;
use Paustian\QuickcheckModule\Entity\QuickcheckQuestionEntity;
use Paustian\QuickcheckModule\Form\QuickcheckTFQuestion;
use Paustian\QuickcheckModule\Form\QuickcheckTextQuestion;
use Paustian\QuickcheckModule\Form\QuickcheckMCQuestion;
use Paustian\QuickcheckModule\Form\QuickcheckMAnsQuestion;
use Paustian\QuickcheckModule\Form\QuickcheckMatchQuestion;

/**
 * The various types of questions. We use defines to make the code
 * easier to read
 */

/**
 * @Route("/admin")
 *
 * Administrative controllers for the quickcheck module
 */
class AdminController extends AbstractController {

    const _QUICKCHECK_TEXT_TYPE = 0;
    const _QUICKCHECK_MULTIPLECHOICE_TYPE = 1;
    const _QUICKCHECK_TF_TYPE = 2;
    const _QUICKCHECK_MATCHING_TYPE = 3;
    const _QUICKCHECK_MULTIANSWER_TYPE = 4;

    /**
     * Post initialise.
     *
     * @return void
     */
    protected function postInitialize() {
        // In this controller we do not want caching.
        $this->view->setCaching(Zikula_View::CACHE_DISABLED);
    }

    /**
     * @Route("")
     * 
     */
    public function indexAction() {

        // Return a page of menu items.
        return new Response($this->render('PaustianQuickcheckModule:Admin:quickcheck_admin_menu.html.twig'));
    }

    /**
     * @Route("/newexam")
     * 
     * * form to add new exam
     *
     * Create a new exam
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new exam response object
     */
    public function newexamAction(Request $request) {
        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $button = $request->request->get('submit', null);
        $render = $this->view;
        $ret_url = $request->request->get('ret_url', null);
        $art_id = $request->request->get('art_id', null);

        if (!isset($art_id)) {
            throw NotFoundHttpException($this->__('You must create quizzes from modules that hook to the quiz module'));
        }
        switch ($button) {
            case 'create':
                // Create output object - this object will store all of our output so that
                // we can return it easily when required

                $questions = $this->_build_questions_list();

                $render->assign('questions', $questions);
                $render->assign('ret_url', $ret_url);
                $render->assign('art_id', $art_id);
                // Return the output that has been generated by this function
                return new Response($render->fetch('Admin\quickcheck_admin_new.tpl'));
                break;
            case 'modify':
                //pass this to modify2
                //first get the exam id, we need this to call modify2 correctly
                $exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('art_id' => $art_id));
                $submit = 'edit_' . $exam['id'];
                //now call the function
                return ModUtil::func('PaustianQuickcheckModule', 'admin', 'modify2', array('submit' => $submit));
                break;
            case 'remove':
                $exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('art_id' => $art_id));
                $exam['art_id'] = -1; //no article attached
                modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'update', $exam);
                return new RedirectResponse($ret_url);
                break;
            case 'attach':
                $exams = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getall');
                //mark the questions that should be checked.

                $render->assign('exams', $exams);
                $render->assign('ret_url', $ret_url);
                $render->assign('art_id', $art_id);
                return new Response($render->fetch('Admin\quickcheck_admin_attach.tpl'));
                break;
        }
    }

    /**
     * @Route ("/attach")
     * @Method("POST")
     * @param Request $request
     * 
     * Parameters of the request are:
     *  ret_url the URL to return to after being done
     *  art_id the article Id of the item that the exam is being attached to
     *  exam the exam that is being attached to the article
     * 
     * @return RedirectResponse
     */
    public function attachAction(Request $request) {
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        //get the values
        $ret_url = $request->request->get('ret_url', null);
        $art_id = $request->request->get('art_id', null);
        $exam = $request->request->get('exam', null);

        //arguments check
        if (!isset($ret_url)) {
            throw new NotFoundHttpException($this->__('A return URL is required'));
        }
        if (!isset($art_id) || !isset($exam)) {
            throw new NotFoundHttpException($this->__('An article id or exam id are missing'));
        }

        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            throw new AccessDeniedException();
            ;
        }
        //get rid of the old exam if there is one.
        $old_exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('art_id' => $art_id));
        if ($old_exam) {
            $old_exam['art_id'] = -1; //no article attached
            modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'update', $old_exam);
        }
        //modify the exam by grabbing it and then changing or adding the art_id
        $exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('id' => $exam));
        $exam['art_id'] = $art_id;
        //now update the exam
        if (modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'update', $exam)) {
            $request->getSession()->getFlashBag()->add('status', $this->__('The exam was attached.'));
        }
        //finally return to the page that called.
        return new RedirectResponse($ret_url);
    }

    private function _build_questions_list() {

        //I am completely stumped on this one. For some reason, calling this funcion inserts a '1' into the
        //text that is returned. For the life of me I cannot find where it is.
        $items = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getallquestions');
        if (!$items) {
            return false;
        }

        $questions = array();
//    This needs to be changed to allow for organization by categoires.
//    The items array has the cat info in it. You just have to bin it.
//    Walk the list, and bin into an array, Each time a new category comes up
//    create a new item and then add each to the list.
        //The data structure is like this
        //$item{__CATEGORIES__][Main][id]
        //$item{__CATEGORIES__][Main][name]
        //use these two to build a multidminsional array
        // load the categories system

        $cat_id = -1;
        $cat_name = "";
        foreach ($items as $question) {
            //create the correct array for the chosen ID's to pass through correctly.
            $built_question['text'] = $question['q_text'];
            $built_question['value'] = $question['id'];
            $built_question['type'] = $question['q_type'];
            if (isset($question['__CATEGORIES__'])) {
                $built_question['cat_id'] = $question['__CATEGORIES__']['Main']['id'];
                $built_question['name'] = $question['__CATEGORIES__']['Main']['name'];
                $questions[$question['__CATEGORIES__']['Main']['sort_value']][] = $built_question;
            } else {
                $built_question['cat_id'] = -1;
                $built_question['name'] = "Uncatagorized";
                $questions['none'][] = $built_question;
            }
        }
        //sort the questions by category name
        ksort($questions);
        //now flatten it out a bit.
        $ret_quest = array();
        foreach ($questions as $question) {
            $ret_quest = array_merge($ret_quest, $question);
        }

        return $ret_quest;
    }

    /**
     * 
     * @Route("/create")
     * @Method("POST")
     * 
     * Create an exam.
     * @param Request $request
     * 
     * Take input from modify2action. Parameters of the request are:
     *  questions - questions to use in exam
     *  ret_url - the return url to redirect to
     *  art_id - the article id to attach if there
     *  name - the name of the exam.
     * 
     *  ret_url the URL to return to after being done
     *  art_id the article Id of the item that the exam is being attached to
     *  exam the exam that is being attached to the article
     * 
     * @return RedirectResponse
     */
    public function createAction(Request $request) {
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $questions = $request->request->get('questions', null);
        $ret_url = $request->request->get('ret_url', null);
        $art_id = $request->request->get('art_id', null);
        $name = $request->request->get('name', null);



        $items = modUtil::apiFunc('paustianquickcheckmodule', 'admin', 'create', array('quickcheckquestions' => $questions,
                    'quickcheckart_id' => $art_id,
                    'quickcheckname' => $name));

        if ($items) {
            SessionUtil::setVar('statusmsg', DataUtil::formatForDisplayHTML("Quick check created"));
        }

        // This function generated no output, and so now it is complete we redirect
        // the user to an appropriate page for them to carry on their work
        return new RedirectResponse($ret_url);
    }

    /**
     * @Route("/newtextquest")
     * form to add new text question
     *
     * Create a new quick_check question
     *
     * @param Request $request
     * @param QuickcheckQuestionEntity $question
     * @return \Symfony\Component\HttpFoundation\RedirectResponse|Response
     */
    public function newTextQuestAction(Request $request, QuickcheckQuestionEntity $question = null) {
        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        if (null === $question) {
            $question = new QuickcheckQuestionEntity();
        }
        //I need to add the use declaration for this class. 
        $form = $this->createForm(new QuickcheckTextQuestion(), $question);

        $form->handleRequest($request);

        /** @var \Doctrine\ORM\EntityManager $em */
        $em = $this->getDoctrine()->getManager();
        if ($form->isValid()) {
            $em->persist($question);
            $em->flush();
            $this->addFlash('status', __('New text question saved!'));

            return $this->redirect($this->generateUrl('paustianquickcheckmodule_admin_newtextquest'));
        }

        return $this->render('PaustianQuickcheckModule:Admin:quickcheck_admin_new_text_question.html.twig', array(
                    'form' => $form->createView(),
        ));
    }


    /**
     * 
     * @Route("/newmatchquest")
     * 
     * form to add new matching question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       Response
     */
    public function newMatchQuestAction(Request $request, QuickcheckQuestionEntity $question = null) {
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        if (null === $question) {
            $question = new QuickcheckQuestionEntity();
        }
        //I need to add the use declaration for this class. 
        $form = $this->createForm(new QuickcheckMatchQuestion(), $question);

        $form->handleRequest($request);

        /** @var \Doctrine\ORM\EntityManager $em */
        $em = $this->getDoctrine()->getManager();
        if ($form->isValid()) {
            $em->persist($question);
            $em->flush();
            $this->addFlash('status', __('Matching Question saved!'));
            $url = $this->generateUrl('paustianquickcheckmodule_admin_newmatchquest');
            return $this->redirect($url);
        }

        return $this->render('PaustianQuickcheckModule:Admin:quickcheck_admin_new_match_question.html.twig', array(
                    'form' => $form->createView(),
        ));
    }

    /**
     * @Route("/newtfquest")
     * form to add new TF question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     *  
     * @param Request $request
     * @param QuickcheckQuestionEntity $question
     * @return \Symfony\Component\HttpFoundation\RedirectResponse|Response
     */
    public function newTFQuestAction(Request $request, QuickcheckQuestionEntity $question = null) {

        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        if (null === $question) {
            $question = new QuickcheckQuestionEntity();
        }
        //I need to add the use declaration for this class. 
        $form = $this->createForm(new QuickcheckTFQuestion(), $question);

        $form->handleRequest($request);

        /** @var \Doctrine\ORM\EntityManager $em */
        $em = $this->getDoctrine()->getManager();
        if ($form->isValid()) {
            $em->persist($question);
            $em->flush();
            $this->addFlash('status', __('Question saved!'));

            return $this->redirect($this->generateUrl('paustianquickcheckmodule_admin_newtfQuest'));
        }

        return $this->render('PaustianQuickcheckModule:Admin:quickcheck_admin_new_tf_question.html.twig', array(
                    'form' => $form->createView(),
        ));
    }

    /**
     * @Route("/newmcquest")
     * 
     * Form to add a new multiple choice question
     * @param array $args
     * @return Response
     * December 16, 2015 - I could not upgrade this because symfony (the form engine part) has a bug in it that
     * relates to collectionTypes. I will have to wait until Symfony >2.7 is used in Zikula
     * 
     * Test data
     * HEre is an answer:100
     * HEre is another:0
     */
    public function newMCQuestAction(Request $request, QuickcheckQuestionEntity $question = null) {
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        if (null === $question) {
            $question = new QuickcheckQuestionEntity();
        }
        //I need to add the use declaration for this class. 
        $form = $this->createForm(new QuickcheckMCQuestion(), $question);

        $form->handleRequest($request);

        /** @var \Doctrine\ORM\EntityManager $em */
        $em = $this->getDoctrine()->getManager();
        if ($form->isValid()) {
            $em->persist($question);
            $em->flush();
            $this->addFlash('status', __('Multiple-Choice Question saved!'));
            $url = $this->generateUrl('paustianquickcheckmodule_admin_newmcquest');
            return $this->redirect($url);
        }

        return $this->render('PaustianQuickcheckModule:Admin:quickcheck_admin_new_mc_question.html.twig', array(
                    'form' => $form->createView(),
        ));
    }

    /**
     * @Route ("/newmansquest")
     * @param   $args the 
     * form to add new multiple answer question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new multiple answer question
     */
    public function newMANSQuestAction(Request $request, QuickcheckQuestionEntity $question = null) {

        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        if (null === $question) {
            $question = new QuickcheckQuestionEntity();
        }
        //I need to add the use declaration for this class. 
        $form = $this->createForm(new QuickcheckMAnsQuestion(), $question);

        $form->handleRequest($request);

        /** @var \Doctrine\ORM\EntityManager $em */
        $em = $this->getDoctrine()->getManager();
        if ($form->isValid()) {
            $em->persist($question);
            $em->flush();
            $this->addFlash('status', __('Multiple-Answer Question saved!'));
            $url = $this->generateUrl('paustianquickcheckmodule_admin_newmansquest');
            return $this->redirect($url);
        }

        return $this->render('PaustianQuickcheckModule:Admin:quickcheck_admin_new_mans_question.html.twig', array(
                    'form' => $form->createView(),
        ));
    }


    /**
     * @Route ("modify")
     * 
     * modify an exam
     *
     * Set up a form to present all the exams and let the user choose
     * The one to modify
     */
    public function modifyAction() {
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            return DataUtil::formatForDisplayHTML($this->__("You do not have permission to add questions."));
        }
        //create a list to choose from. I think I will use radio buttons
        //because that is easier to deal with.
        $render = zikula_View::getInstance('Quickcheck', false);
        //get the exams
        $exams = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getall');
        $render->assign('exams', $exams);
        // Return the output that has been generated by this function
        return new Response($render->fetch('Admin\quickcheck_admin_modify.tpl'));
    }

    /**
     * 
     * modify2. The second phase of the modify form
     * @Route ("modify2")
     * @Method("POST")
     * 
     * @param Request $request
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    public function modify2Action(Request $request) {
        //security check
        $this->checkCsrfToken();

        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        //Find out the button that was pressed
        $button = $request->request->get('submit', null);
        $redirect_url = $this->get('router')->generate('paustianquickcheckmodule_admin_modify', array(), RouterInterface::ABSOLUTE_URL);
        //delete all the checked items
        if ($button === 'delete_exams') {
            if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_DELETE)) {
                throw new AccessDeniedException();
            }
            $exams = $request->request->get('exams', null);
            //check to make sure we have something
            if (!empty($questions)) {
                //we have the list, now delete the questions
                foreach ($questions as $item) {
                    modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'delete', array('id' => $item));
                }
            }
            $request->getSession()->getFlashBag()->add('status', $this->__('The exams were deleted.'));
            return new RedirectResponse($redirect_url);
        }
        //it's not the delete button. determine value
        $string_data = explode("_", $button);
        //find the command we need to do
        $command = $string_data[0];
        //get the id the exam.
        $id = $string_data[1];
        if ($command == 'edit') {
            $the_exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('id' => $id));
            $curr_quest_array = array();
            $other_array = array();
            //grab the current questions.
            $questions = $this->_build_questions_list();
            $curr_quest_ids = $the_exam['questions'];

            //search the question array and pick out the ones that are
            //current questions
            foreach ($questions as $q_data) {
                $item['q_text'] = $q_data['text'];
                $item['id'] = $q_data['value'];

                if (array_search($q_data['value'], $curr_quest_ids) !== false) {
                    $curr_quest_array[] = $item;
                } else {
                    $item['cat_id'] = $q_data['cat_id'];
                    $item['cat_name'] = $q_data['name'];
                    $other_array[] = $item;
                }
            }

            $render = $this->view;
            $render->assign('exam', $the_exam);
            $render->assign('curr_questions', $curr_quest_array);
            $render->assign('other_questions', $other_array);
            return new Response($render->fetch('Admin\quickcheck_admin_modify2.tpl'));
        }
        return new RedirectResponse($redirect_url);
    }


    /**
     * 
     * modify2. The second phase of the modify form
     * @Route ("modifyquest2")
     * @Method("POST")
     * 
     * @param Request $request
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    public function modifyquest2Action(Request $request) {

        //security check
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $id = $request->request->get('id', null);
        $redirect_url = $this->get('router')->generate('paustianquickcheckmodule_admin_editquestions', array(), RouterInterface::ABSOLUTE_URL);

        if (!isset($id)) {
            $request->getSession()->getFlashBag()->add('status', $this->__("The id is not set in modidfyquest2"));
            return RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
        }
        //grab the question
        $item = modUtil::apiFunc('PaustianQuickcheckmodule', 'user', 'getquestion', array('id' => $id));

        if (!$item) {
            $request->getSession()->getFlashBag()->add('status', $this->__("A question with that id does not exist"));
            return RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
        }

        switch ($item['q_type']) {
            case self::_QUICKCHECK_TEXT_TYPE:
                return $this->modifyTextQuest(array('item' => $item));
                break;
            case self::_QUICKCHECK_MATCHING_TYPE:
                return $this->modifyMatchQuest(array('item' => $item));
                break;
            case self::_QUICKCHECK_MULTIANSWER_TYPE:
                return $this->modifyMANSQuest(array('item' => $item));
                break;
            case self::_QUICKCHECK_MULTIPLECHOICE_TYPE:
                return $this->modifyMCQuest(array('item' => $item));
                break;
            case self::_QUICKCHECK_TF_TYPE:
                return $this->modifyTFQuest(array('item' => $item));
                break;
        }
    }

    /**
     * 
     * form to add modify a T/F question
     *
     * Create a new quick_check question
     * 
      @param Request $request
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new text question
     */
    public function modifyTFQuest($request) {

        $item = $request->request->get('item', null);

        return $this->newTFQuest($item);
    }

    private function _setup_form($inItem = null) {
        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            return DataUtil::formatForDisplayHTML($this->__("You do not have permission to add questions."));
        }

        // Create output object - this object will store all of our output so that
        // we can return it easily when required
        $render = zikula_View::getInstance('Quickcheck', false);
        if (isset($inItem)) {
            $render->assign('q_text', $inItem['q_text']);
            $render->assign('q_answer', $inItem['q_answer']);
            if (isset($inItem['q_explan'])) {
                $render->assign('q_explan', $inItem['q_explan']);
            }

            //I finally figured this out. I needed to pull out what from the categories
            //is getting selected. What is stored with my table, is the id of the item
            //selected. By assigning this to selectedValue in the template, it gets
            //chosen in the category menu. See the templates for the way it's handled.
            //I should probably be more clever and no just grab the 'Main' property,
            //but that is the one I am always going to use.
            if (isset($inItem['__CATEGORIES__']['Main'])) {
                $cat = $inItem['__CATEGORIES__']['Main'];
                //print "<br />";print $cat['id'];die;
                $render->assign('selectedValue', $cat['id']);
            }
        }
        return $render;
    }

    /**
     * form to add modify a text question
     *
     * Create a new quick_check question
     *
     * @author       Timothy Paustian
     * @return       The form for creating a new text question
     */
    public function modifyTextQuest($args) {

        $item = $request->request->get('item', null);

        return( $this->newTextQuest($item));
    }

    private function _setUpMANSMC($data) {

        // Security check - important to do this as early as possible to avoid
        // potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_ADD)) {
            throw new AccessDeniedException();
        }
        $data['num_mc_choices'] = count($data['q_answer']);
        return $data;
    }

    public function modifyMCQuest(Request $request) {
        $data = $request->request->get('item', null);

        $data = $this->_setUpMANSMC($data);
        return $this->newMCQuest($data);
    }

    public function modifyMANSQuest(Request $request) {
        $data = $request->request->get('item', null);

        $data = $this->_setupMANSMC($data);

        return $this->newMANSQuest($data);
    }

    public function modifyMatchQuest(Request $request) {
        $data = $request->request->get('item', null);

        $data = $this->_setupMANSMC($data);
        return $this->newMatchQuest($data);
    }

    /**
     * 
     * @Route("/update")
     * @Method POST
     * 
     * Modify an exam
     *
     * This is a standard function that is called with the results of the
     * form supplied by quickcheck_admin_modify2() to update a current exam
     *
     * @param Request $request
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    public function updateAction(Request $request) {
        // Confirm authorisation code.
        //security check
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $curr_questions = $request->request->get('curr_questions', null);
        $other_questions = $request->request->get('other_questions', null);
        $name = $request->request->get('name', null);
        $id = $request->request->get('exam_id', null);
        if (isset($other_questions) && isset($curr_questions)) {
            $total_questions = array_merge($curr_questions, $other_questions);
        } else if (isset($other_questions)) {
            $total_questions = $other_questions;
        } else if (isset($curr_questions)) {
            $total_questions = $curr_questions;
        } else {
            $total_questions = array();
        }
        if (modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'update', array('name' => $name, 'id' => $id, 'questions' => $total_questions))) {
            $request->getSession()->getFlashBag()->add('status', $this->__("The exam was updated."));
        }
        return new RedirectResponse(ModUtil::url('PaustianQuickcheckModule', 'admin', 'modify'));
    }

    /**
     * @Route("/editquestions")
     * 
     * edit questions
     *
     *  This is the interface for modifying and deleting questions. I combined the
     *  two to make it more accessible to the user. The function displays a list of
     *  questions, and from there a user can edit or delete a question.
     * 
     * @return Response
     * @throws AccessDeniedException
     * 
     */
    public function editquestionsAction() {
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $items = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getallquestions');

        if (!$items) {
            $request->getSession()->getFlashBag()->add('status', $this->__("There are no quesitons to modify"));
            return RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
        }
    }

    private function _prep_question_list($buttons = "no") {

        //To use this function you need high access
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_DELETE)) {
            throw new AccessDeniedException();
        }

        $questions = $this->_build_questions_list();

        if (!$questions) {
            return LogUtil::registerError('There are no questions to modify. Create some first.');
        }
        $render->assign('questions', $questions);
        $render->assign('buttons', $buttons);

        return new Response($render->fetch('Admin\quickcheck_admin_qpart.tpl'));
    }

    /**
     * @Route("/modifydeletequesions")
     * 
     * presents a list of questions that you can then modify or delete.
     * 
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    public function modifydeletequestionsAction() {

        //Find out the button that was pressed
        $button = $request->request->get('submit', null);
        if (!isset($button)) {
            $button = $request->request->get('plg4_update', null);
        }
        $redirect_url = $this->get('router')->generate('paustianquickcheckmodule_admin_editquestions', array(), RouterInterface::ABSOLUTE_URL);
        //delete all the checked items

        if ($button === 'delete_checked') {
            if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_DELETE)) {
                throw new AccessDeniedException();
            }
            $questions = $request->request->get('questions', null);
            $delete_all = $request->request->get('delete_all', null);
            //check to make sure we have something
            if (!empty($questions)) {
                //we have the list, now delete the questions
                foreach ($questions as $item) {
                    if (!modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'deletequestion', array('id' => $item))) {
                        $request->getSession()->getFlashBag()->add('status', $this->__("There was an error deleting the quesiton."));
                        return RedirectResponse($this->get('router')->generate('paustianquickcheckmodule_admin_index', array(), RouterInterface::ABSOLUTE_URL));
                        ;
                    }
                }
                //if we get here, it worked.
                $request->getSession()->getFlashBag()->add('status', $this->__("The choosen question(s) were deleted"));
            } else {
                if ($delete_all == "on") {
                    $questions = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getallquestions');
                    if (!$questions) {
                        $request->getSession()->getFlashBag()->add('status', $this->__('There are no questions to modify. Create some first.'));
                        return new RedirectResponse($redirect_url);
                    }
                    foreach ($questions as $q_item) {
                        if (!modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'deletequestion', array('id' => $q_item['id']))) {
                            //if we have an error, bail, the error is already posted.
                            return new RedirectResponse($redirect_url);
                        }
                    }
                    //if we got here, all the question are deleted, we need to redirect somewhere else
                    //post a status message too.
                    $request->getSession()->getFlashBag()->add('status', $this->__("All questions were deleted"));
                    return new RedirectResponse(ModUtil::url('PaustianQuickcheckModule', 'admin', 'editquestions'));
                }
            }
            return new RedirectResponse($redirect_url);
        }
        if ($button === 'modify_checked') {
            if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
                throw new AccessDeniedException();
            }
            //I have bad data in the MC, MAtching etc. questions Reimport I guess
            $questions = $request->request->get('questions', null);
            $id = $questions[0];
            return $this->modifyquest2(array('id' => $id));
        }
        //parse the button if we get to this point
        $button_parts = explode('_', $button);
        if ($button_parts[0] == "modify") {
            if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
                throw new AccessDeniedException();
            }
            //we want to edit the question identified. This is coming from find unanswered.
            //the second part of the phrase is the id of the button
            return $this->modifyquest2(array('id' => $button_parts[1]));
        }

        return new RedirectResponse($redirect_url);
    }

    /**
     * 
     * @Route("/manageexams")
     * @Method("POST")
     * 
     * @param Request $request
     * 
     * Manage exams
     *
     * This is the hook funciton that attaches/deletes/modifies an exam, with
     * questions, to another module. This is the interface that takes care of
     * those functions. What gets passed in, may be the id of the exam. If not
     * then we display an interface for choosing questions for the exam.
     * 
     * 
     */
    public function manageexamsAction(Request $request) {
        $art_id = $request->request->get('objectid', null);
        $ret_url = $request->request->get('extrainfo', null);
        $module = $request->request->get('extrainfo', null);
        $ret_text = "";
        $exam = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'get', array('art_id' => $art_id));

        if ($exam) {
            $ret_text = ModUtil::func('PaustianQuickcheckModule', 'user', 'display', array('exam' => $exam, 'returnurl' => $ret_url));
            $render = $this->view;
            $render->assign('hasexam', 1);
        }
        //no exam, display an interface to pick one, only if this is an admin
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            //we return an empty results for someone who cannot edit, you don't want to fail here
            //as each hooked page would then have the error message.
            return $ret_text;
        } else {
            $ret_text .= "<hr />" . ModUtil::func('PaustianQuickcheckModule', 'admin', 'pickquestions', array('returnurl' => $ret_url, 'art_id' => $art_id));
        }
        return $ret_text;
    }

    /**
     * @Route("/pickquestions")
     * @Method("POST")
     * 
     * Pick questions
     *
     * Display an interface for picking questions. Really this will just be a button
     * that will lead to a page where you can add questions to an exam.
     *
     * @param Request
     * @return Response
     */
    public function pickquestionsAction(Request $request) {
        // Confirm authorisation code.
        //security check
        $this->checkCsrfToken();
        if (!SecurityUtil::checkPermission('quickcheck::', '::', ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $ret_url = $request->request->get('returnurl', null);
        $art_id = $request->request->get('art_id', null);
        $render = $this->view;
        $render->assign('ret_url', $ret_url);
        $render->assign('art_id', $art_id);
        return new Response($render->fetch('Admin\quickcheck_admin_pickquestions.tpl'));
    }

    /**
     * @Route("/categorize")
     * 
     * Present an interface for puttin uncategorized quesitons into categories
     * 
     * @param Request $request
     * @return Response
     */
    public function categorizeAction() {
        $questions = $this->_prep_question_list();
        $render = zikula_View::getInstance('Quickcheck', false);
        $render->assign('questions', $questions);

        return new Response($render->fetch('Admin\quickcheck_admin_categorize.tpl'));
    }

    /**
     * @Route("/addtocategory")
     * @Method("POST")
     * 
     * Take the category that was recorded and  add it to the selected questions
     * 
     * @param Request $request
     * @return RedirectResponse
     * @throws AccessDeniedException
     */
    public function addtocategoryAction(Request $request) {
        // Confirm authorisation code.
        //security check
        $this->checkCsrfToken();

        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        //get the questions
        $questions = $request->request->get('questions', null);
        //get the category
        $cat = $request->request->get('quickcheck_quest', null);
        foreach ($questions as $the_question) {
            $item = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getquestion', array('id' => $the_question));
            $item['__CATEGORIES__'] = $cat['__CATEGORIES__'];

            if (!modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'updatequestion', $item)) {
                return LogUtil::registerError("Update in category failed.");
            }
        }
        //if we have gotten here, we were successful
        $request->getSession()->getFlashBag()->add('status', $this->__('Categories updated.'));
        return new RedirectResponse(ModUtil::url('PaustianQuickcheckModule', 'admin', 'categorize'));
    }

    /**
     * @Route("/findunanswered")
     * 
     * findunanswered
     *
     * This is a quick function to find all the unexplained questions in the module
     * It's really a hack and isn't something you should be calling, I am just using
     * it for clean up of some previous data. It will likely go away in a future release
     *
     *  @return Response
     *  @throws AccessDeniedException
     */
    public function findunansweredAction() {
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        $questions = modUtil::apiFunc('PaustianQuickcheckModule', 'user', 'getallquestions', array('missing_explan' => true));

        $render = zikula_View::getInstance('Quickcheck', false);
        $render->assign('count', count($questions));
        $render->assign('questions', $questions);
        return new Response($render->fetch('Admin/quickcheck_admin_findunanswered.tpl'));
    }

    /**
     * @Route("/importquiz")
     * 
     * set up the interface to import an xml file of quiz questions.
     * @return Response
     * @throws AccessDeniedException
     */
    public function importquizAction() {
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }
        return new Response($this->view->fetch('Admin/quickcheck_admin_importquiz.tpl'));
    }

    /**
     * @Route("/doimport")
     * @Method("POST")
     * 
     * import questions as xml
     *
     * Given a set of data in xml format, parse it and improt the questions. There
     * is a set format, with examples given in the template for the page
     *
     * @author      Tim Paustian
     * @param      Request
     * @return    RedirectReponse
     *
     */
    public function doimportAction(Request $request) {
        $ret_url = $this->get('router')->generate('paustianquickcheckmodule_admin_importquiz', array(), RouterInterface::ABSOLUTE_URL);
        // Confirm authorisation code.
        //security check
        $this->checkCsrfToken();
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        //get the questions
        $questions = $request->request->get('quest_to_import', null);

        if (modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'import', array('questions' => $questions))) {
            $request->getSession()->getFlashBag()->add('status', $this->__('Import of questions was successful.'));
            ;
        } else {
            LogUtil::registerError(__('The import of questions did not work, probably because of poorly formed xml or because of an illegal character'), null, $ret_url);
        }
        return new RedirectResponse($ret_url);
    }

    /**
     * @Route("/exportquiz")
     * 
     * export the chose quiz. First step. This displays the interface to export the questions
     * @return Response
     * @throws AccessDeniedException
     */
    public function exportquizAction() {

        //You need edit access to export questions
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }
        $questions = $this->_prep_question_list("yes");
        $render = $this->view;
        $render->assign('questions', $questions);
        return new Response($render->fetch('Admin/quickcheck_admin_exportquiz.tpl'));
    }

    /**
     * @Route("/doexport")
     * @Method("POST")
     * 
     * Export the choosen questions into an xml file
     * 
     * @param Request $request
     * @throws AccessDeniedException
     */
    public function doexportAction(Request $request) {
        $ret_url = $this->get('router')->generate('paustianquickcheckmodule_admin_export', array(), RouterInterface::ABSOLUTE_URL);
        // Confirm authorisation code.
        //security check
        $this->checkCsrfToken();
        //you have to have edit access to do this
        if (!SecurityUtil::checkPermission('quickcheck::', "::", ACCESS_EDIT)) {
            throw new AccessDeniedException();
        }

        //get the questions
        $export_all = $request->request->get('export_all', null);
        $q_ids = $request->request->get('questions', null);

        $q_xml = modUtil::apiFunc('PaustianQuickcheckModule', 'admin', 'export', array('export_all' => $export_all, 'q_ids' => $q_ids));

        $render = $this->view;
        $render->assign('questions', $q_xml);
        return new Response($render->fetch('Admin/quickcheck_admin_doexport.tpl'));
    }

}
